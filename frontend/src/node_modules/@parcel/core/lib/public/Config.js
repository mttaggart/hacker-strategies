"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _Environment() {
  const data = _interopRequireDefault(require("./Environment"));

  _Environment = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to get private field on non-instance"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to set private field on non-instance"); } if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } return value; }

const internalConfigToConfig = new (_utils().DefaultWeakMap)(() => new WeakMap());

var _config = new WeakMap();

var _pkg = new WeakMap();

var _pkgFilePath = new WeakMap();

var _options = new WeakMap();

class PublicConfig {
  /*: Config */

  /*: ?PackageJSON */

  /*: ?FilePath */
  constructor(config, options) {
    _config.set(this, {
      writable: true,
      value: void 0
    });

    _pkg.set(this, {
      writable: true,
      value: void 0
    });

    _pkgFilePath.set(this, {
      writable: true,
      value: void 0
    });

    _options.set(this, {
      writable: true,
      value: void 0
    });

    let existing = internalConfigToConfig.get(options).get(config);

    if (existing != null) {
      return existing;
    }

    _classPrivateFieldSet(this, _config, config);

    _classPrivateFieldSet(this, _options, options);

    internalConfigToConfig.get(options).set(config, this);
    return this;
  }

  get env() {
    return new (_Environment().default)(_classPrivateFieldGet(this, _config).env);
  }

  get searchPath() {
    return _classPrivateFieldGet(this, _config).searchPath;
  }

  get result() {
    return _classPrivateFieldGet(this, _config).result;
  }

  get isSource() {
    return _classPrivateFieldGet(this, _config).isSource;
  }

  get includedFiles() {
    return _classPrivateFieldGet(this, _config).includedFiles;
  } // $FlowFixMe


  setResult(result) {
    _classPrivateFieldGet(this, _config).result = result;
  }

  setResultHash(resultHash) {
    _classPrivateFieldGet(this, _config).resultHash = resultHash;
  }

  addIncludedFile(filePath) {
    _classPrivateFieldGet(this, _config).includedFiles.add(filePath);
  }

  addDevDependency(devDep) {
    _classPrivateFieldGet(this, _config).devDeps.push(devDep);
  }

  invalidateOnFileCreate(invalidation) {
    _classPrivateFieldGet(this, _config).invalidateOnFileCreate.push(invalidation);
  }

  shouldInvalidateOnStartup() {
    _classPrivateFieldGet(this, _config).shouldInvalidateOnStartup = true;
  }

  async getConfigFrom(searchPath, fileNames, options) {
    let packageKey = options && options.packageKey;

    if (packageKey != null) {
      let pkg = await this.getPackage();

      if (pkg && pkg[packageKey]) {
        return {
          contents: pkg[packageKey],
          // This should be fine as pkgFilePath should be defined by getPackage()
          filePath: _classPrivateFieldGet(this, _pkgFilePath) || ''
        };
      }
    }

    if (fileNames.length === 0) {
      return null;
    } // Invalidate when any of the file names are created above the search path.


    for (let fileName of fileNames) {
      this.invalidateOnFileCreate({
        fileName,
        aboveFilePath: searchPath
      });
    }

    let parse = options && options.parse;
    let conf = await (0, _utils().loadConfig)(_classPrivateFieldGet(this, _options).inputFS, searchPath, fileNames, parse == null ? null : {
      parse
    });

    if (conf == null) {
      return null;
    }

    let configFilePath = conf.files[0].filePath;

    if (!options || !options.exclude) {
      this.addIncludedFile(configFilePath);
    }

    return {
      contents: conf.config,
      filePath: configFilePath
    };
  }

  getConfig(filePaths, options) {
    return this.getConfigFrom(this.searchPath, filePaths, options);
  }

  async getPackage() {
    if (_classPrivateFieldGet(this, _pkg)) {
      return _classPrivateFieldGet(this, _pkg);
    }

    let pkgConfig = await this.getConfig(['package.json']);

    if (!pkgConfig) {
      return null;
    }

    _classPrivateFieldSet(this, _pkg, pkgConfig.contents);

    _classPrivateFieldSet(this, _pkgFilePath, pkgConfig.filePath);

    return _classPrivateFieldGet(this, _pkg);
  }

}

exports.default = PublicConfig;