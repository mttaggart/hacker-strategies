"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _v() {
  const data = _interopRequireDefault(require("v8"));

  _v = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _stream() {
  const data = require("stream");

  _stream = function () {
    return data;
  };

  return data;
}

function _sourceMap() {
  const data = _interopRequireDefault(require("@parcel/source-map"));

  _sourceMap = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _Dependency() {
  const data = require("./Dependency");

  _Dependency = function () {
    return data;
  };

  return data;
}

function _Environment() {
  const data = require("./Environment");

  _Environment = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("./constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _assetUtils() {
  const data = require("./assetUtils");

  _assetUtils = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class UncommittedAsset {
  constructor({
    value,
    options,
    content,
    mapBuffer,
    ast,
    isASTDirty,
    idBase,
    invalidations,
    fileCreateInvalidations
  }) {
    _defineProperty(this, "value", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "content", void 0);

    _defineProperty(this, "mapBuffer", void 0);

    _defineProperty(this, "map", void 0);

    _defineProperty(this, "ast", void 0);

    _defineProperty(this, "isASTDirty", void 0);

    _defineProperty(this, "idBase", void 0);

    _defineProperty(this, "invalidations", void 0);

    _defineProperty(this, "fileCreateInvalidations", void 0);

    this.value = value;
    this.options = options;
    this.content = content;
    this.mapBuffer = mapBuffer;
    this.ast = ast;
    this.isASTDirty = isASTDirty || false;
    this.idBase = idBase;
    this.invalidations = invalidations || new Map();
    this.fileCreateInvalidations = fileCreateInvalidations || [];
  }
  /*
   * Prepares the asset for being serialized to the cache by commiting its
   * content and map of the asset to the cache.
   */


  async commit(pipelineKey) {
    // If there is a dirty AST, clear out any old content and map as these
    // must be regenerated later and shouldn't be committed.
    if (this.ast != null && this.isASTDirty) {
      this.content = null;
      this.mapBuffer = null;
    }

    let size = 0;
    let contentKey = this.content == null ? null : this.getCacheKey('content' + pipelineKey);
    let mapKey = this.mapBuffer == null ? null : this.getCacheKey('map' + pipelineKey);
    let astKey = this.ast == null ? null : this.getCacheKey('ast' + pipelineKey); // Since we can only read from the stream once, compute the content length
    // and hash while it's being written to the cache.

    await Promise.all([contentKey != null && this.commitContent(contentKey).then(s => size = s), this.mapBuffer != null && mapKey != null && this.options.cache.setBlob(mapKey, this.mapBuffer), astKey != null && this.options.cache.setBlob(astKey, // $FlowFixMe
    _v().default.serialize(this.ast))]);
    this.value.contentKey = contentKey;
    this.value.mapKey = mapKey;
    this.value.astKey = astKey;
    this.value.outputHash = (0, _utils().md5FromString)([this.value.hash, pipelineKey, await (0, _assetUtils().getInvalidationHash)(this.getInvalidations(), this.options)].join(':'));

    if (this.content != null) {
      this.value.stats.size = size;
    }

    this.value.committed = true;
  }

  async commitContent(contentKey) {
    let content = await this.content;

    if (content == null) {
      return 0;
    }

    let size = 0;

    if (content instanceof _stream().Readable) {
      await this.options.cache.setStream(contentKey, content.pipe(new (_utils().TapStream)(buf => {
        size += buf.length;
      })));
      return size;
    }

    if (typeof content === 'string') {
      size = Buffer.byteLength(content);
    } else {
      size = content.length;
    }

    await this.options.cache.setBlob(contentKey, content);
    return size;
  }

  async getCode() {
    if (this.ast != null && this.isASTDirty) {
      throw new Error('Cannot call getCode() on an asset with a dirty AST. For transformers, implement canReuseAST() and check asset.isASTDirty.');
    }

    let content = await this.content;

    if (typeof content === 'string' || content instanceof Buffer) {
      return content.toString();
    } else if (content != null) {
      this.content = (0, _utils().bufferStream)(content);
      return (await this.content).toString();
    }

    (0, _assert().default)(false, 'Internal error: missing content');
  }

  async getBuffer() {
    let content = await this.content;

    if (content == null) {
      return Buffer.alloc(0);
    } else if (typeof content === 'string' || content instanceof Buffer) {
      return Buffer.from(content);
    }

    this.content = (0, _utils().bufferStream)(content);
    return this.content;
  }

  getStream() {
    var _this$content;

    if (this.content instanceof _stream().Readable) {
      // Remove content if it's a stream, as it should not be reused.
      let content = this.content;
      this.content = null;
      return content;
    }

    if (this.content instanceof Promise) {
      return (0, _utils().streamFromPromise)(this.content);
    }

    return (0, _utils().blobToStream)((_this$content = this.content) !== null && _this$content !== void 0 ? _this$content : Buffer.alloc(0));
  }

  setCode(code) {
    this.content = code;
    this.clearAST();
  }

  setBuffer(buffer) {
    this.content = buffer;
    this.clearAST();
  }

  setStream(stream) {
    this.content = stream;
    this.clearAST();
  }

  async loadExistingSourcemap() {
    if (this.map) {
      return this.map;
    }

    let code = await this.getCode();
    let map = await (0, _utils().loadSourceMap)(this.value.filePath, code, {
      fs: this.options.inputFS,
      projectRoot: this.options.projectRoot
    });

    if (map) {
      this.map = map;
      this.mapBuffer = map.toBuffer();
      this.setCode(code.replace(_utils().SOURCEMAP_RE, ''));
    }

    return this.map;
  }

  getMapBuffer() {
    return Promise.resolve(this.mapBuffer);
  }

  async getMap() {
    if (this.map == null) {
      var _this$mapBuffer;

      let mapBuffer = (_this$mapBuffer = this.mapBuffer) !== null && _this$mapBuffer !== void 0 ? _this$mapBuffer : await this.getMapBuffer();

      if (mapBuffer) {
        // Get sourcemap from flatbuffer
        let map = new (_sourceMap().default)(this.options.projectRoot);
        map.addBufferMappings(mapBuffer);
        this.map = map;
      }
    }

    return this.map;
  }

  setMap(map) {
    this.mapBuffer = map === null || map === void 0 ? void 0 : map.toBuffer();
  }

  getAST() {
    return Promise.resolve(this.ast);
  }

  setAST(ast) {
    this.ast = ast;
    this.isASTDirty = true;
    this.value.astGenerator = {
      type: ast.type,
      version: ast.version
    };
  }

  clearAST() {
    this.ast = null;
    this.isASTDirty = false;
    this.value.astGenerator = null;
  }

  getCacheKey(key) {
    return (0, _utils().md5FromString)(_constants().PARCEL_VERSION + key + this.value.id + (this.value.hash || ''));
  }

  addDependency(opts) {
    // eslint-disable-next-line no-unused-vars
    let {
      env,
      target,
      symbols,
      ...rest
    } = opts;
    let dep = (0, _Dependency().createDependency)({ ...rest,
      // $FlowFixMe "convert" the $ReadOnlyMaps to the interal mutable one
      symbols,
      env: (0, _Environment().mergeEnvironments)(this.value.env, env),
      sourceAssetId: this.value.id,
      sourcePath: this.value.filePath
    });
    let existing = this.value.dependencies.get(dep.id);

    if (existing) {
      (0, _Dependency().mergeDependencies)(existing, dep);
    } else {
      this.value.dependencies.set(dep.id, dep);
    }

    return dep.id;
  }

  addIncludedFile(filePath) {
    let invalidation = {
      type: 'file',
      filePath
    };
    this.invalidations.set((0, _assetUtils().getInvalidationId)(invalidation), invalidation);
  }

  invalidateOnFileCreate(invalidation) {
    this.fileCreateInvalidations.push(invalidation);
  }

  invalidateOnEnvChange(key) {
    let invalidation = {
      type: 'env',
      key
    };
    this.invalidations.set((0, _assetUtils().getInvalidationId)(invalidation), invalidation);
  }

  getInvalidations() {
    return [...this.invalidations.values()];
  }

  getDependencies() {
    return Array.from(this.value.dependencies.values());
  }

  createChildAsset(result, plugin, configPath, configKeyPath) {
    var _result$content, _result$isIsolated, _result$isInline, _result$isSplittable, _result$isSource, _result$pipeline, _result$sideEffects;

    let content = (_result$content = result.content) !== null && _result$content !== void 0 ? _result$content : null;
    let asset = new UncommittedAsset({
      value: (0, _assetUtils().createAsset)({
        idBase: this.idBase,
        hash: this.value.hash,
        filePath: this.value.filePath,
        type: result.type,
        query: result.query,
        isIsolated: (_result$isIsolated = result.isIsolated) !== null && _result$isIsolated !== void 0 ? _result$isIsolated : this.value.isIsolated,
        isInline: (_result$isInline = result.isInline) !== null && _result$isInline !== void 0 ? _result$isInline : this.value.isInline,
        isSplittable: (_result$isSplittable = result.isSplittable) !== null && _result$isSplittable !== void 0 ? _result$isSplittable : this.value.isSplittable,
        isSource: (_result$isSource = result.isSource) !== null && _result$isSource !== void 0 ? _result$isSource : this.value.isSource,
        env: (0, _Environment().mergeEnvironments)(this.value.env, result.env),
        dependencies: this.value.type === result.type ? new Map(this.value.dependencies) : new Map(),
        meta: { ...this.value.meta,
          ...result.meta
        },
        pipeline: (_result$pipeline = result.pipeline) !== null && _result$pipeline !== void 0 ? _result$pipeline : this.value.type === result.type ? this.value.pipeline : null,
        stats: {
          time: 0,
          size: this.value.stats.size
        },
        // $FlowFixMe
        symbols: result.symbols,
        sideEffects: (_result$sideEffects = result.sideEffects) !== null && _result$sideEffects !== void 0 ? _result$sideEffects : this.value.sideEffects,
        uniqueKey: result.uniqueKey,
        astGenerator: result.ast ? {
          type: result.ast.type,
          version: result.ast.version
        } : null,
        plugin,
        configPath,
        configKeyPath
      }),
      options: this.options,
      content,
      ast: result.ast,
      isASTDirty: result.ast === this.ast ? this.isASTDirty : true,
      mapBuffer: result.map ? result.map.toBuffer() : null,
      idBase: this.idBase,
      invalidations: this.invalidations,
      fileCreateInvalidations: this.fileCreateInvalidations
    });
    let dependencies = result.dependencies;

    if (dependencies) {
      for (let dep of dependencies) {
        asset.addDependency(dep);
      }
    }

    return asset;
  }

  async getConfig(filePaths, options) {
    let conf = await (0, _assetUtils().getConfig)(this, filePaths, options);

    if (conf == null) {
      return null;
    }

    for (let file of conf.files) {
      this.addIncludedFile(file.filePath);
    }

    return conf.config;
  }

  getPackage() {
    return this.getConfig(['package.json']);
  }

}

exports.default = UncommittedAsset;