"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAsset = createAsset;
exports.generateFromAST = generateFromAST;
exports.getConfig = getConfig;
exports.getInvalidationId = getInvalidationId;
exports.getInvalidationHash = getInvalidationHash;

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _stream() {
  const data = require("stream");

  _stream = function () {
    return data;
  };

  return data;
}

function _crypto() {
  const data = _interopRequireDefault(require("crypto"));

  _crypto = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@parcel/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _CommittedAsset() {
  const data = _interopRequireDefault(require("./CommittedAsset"));

  _CommittedAsset = function () {
    return data;
  };

  return data;
}

function _UncommittedAsset() {
  const data = _interopRequireDefault(require("./UncommittedAsset"));

  _UncommittedAsset = function () {
    return data;
  };

  return data;
}

function _loadParcelPlugin() {
  const data = _interopRequireDefault(require("./loadParcelPlugin"));

  _loadParcelPlugin = function () {
    return data;
  };

  return data;
}

function _Asset() {
  const data = require("./public/Asset");

  _Asset = function () {
    return data;
  };

  return data;
}

function _PluginOptions() {
  const data = _interopRequireDefault(require("./public/PluginOptions"));

  _PluginOptions = function () {
    return data;
  };

  return data;
}

function _utils2() {
  const data = require("./utils");

  _utils2 = function () {
    return data;
  };

  return data;
}

function _buildCache() {
  const data = require("./buildCache");

  _buildCache = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createAssetIdFromOptions(options) {
  var _options$uniqueKey, _options$pipeline;

  let uniqueKey = (_options$uniqueKey = options.uniqueKey) !== null && _options$uniqueKey !== void 0 ? _options$uniqueKey : '';
  let idBase = options.idBase != null ? options.idBase : options.filePath;
  let queryString = options.query ? (0, _utils().objectSortedEntries)(options.query) : '';
  return (0, _utils().md5FromOrderedObject)({
    idBase,
    type: options.type,
    env: options.env.id,
    uniqueKey,
    pipeline: (_options$pipeline = options.pipeline) !== null && _options$pipeline !== void 0 ? _options$pipeline : '',
    queryString
  });
}

function createAsset(options) {
  var _options$committed, _options$isIsolated, _options$isInline, _options$sideEffects, _options$uniqueKey2;

  return {
    id: options.id != null ? options.id : createAssetIdFromOptions(options),
    committed: (_options$committed = options.committed) !== null && _options$committed !== void 0 ? _options$committed : false,
    hash: options.hash,
    filePath: options.filePath,
    query: options.query,
    isIsolated: (_options$isIsolated = options.isIsolated) !== null && _options$isIsolated !== void 0 ? _options$isIsolated : false,
    isInline: (_options$isInline = options.isInline) !== null && _options$isInline !== void 0 ? _options$isInline : false,
    isSplittable: options.isSplittable,
    type: options.type,
    contentKey: options.contentKey,
    mapKey: options.mapKey,
    astKey: options.astKey,
    astGenerator: options.astGenerator,
    dependencies: options.dependencies || new Map(),
    isSource: options.isSource,
    outputHash: options.outputHash,
    pipeline: options.pipeline,
    env: options.env,
    meta: options.meta || {},
    stats: options.stats,
    symbols: options.symbols,
    sideEffects: (_options$sideEffects = options.sideEffects) !== null && _options$sideEffects !== void 0 ? _options$sideEffects : true,
    uniqueKey: (_options$uniqueKey2 = options.uniqueKey) !== null && _options$uniqueKey2 !== void 0 ? _options$uniqueKey2 : '',
    plugin: options.plugin,
    configPath: options.configPath,
    configKeyPath: options.configKeyPath
  };
}

const generateResults = new WeakMap();

function generateFromAST(asset) {
  let output = generateResults.get(asset.value);

  if (output == null) {
    output = _generateFromAST(asset);
    generateResults.set(asset.value, output);
  }

  return output;
}

async function _generateFromAST(asset) {
  var _plugin$generate;

  let ast = await asset.getAST();

  if (ast == null) {
    throw new Error('Asset has no AST');
  }

  let pluginName = (0, _nullthrows().default)(asset.value.plugin);
  let {
    plugin
  } = await (0, _loadParcelPlugin().default)(pluginName, (0, _nullthrows().default)(asset.value.configPath), (0, _nullthrows().default)(asset.value.configKeyPath), asset.options);
  let generate = (_plugin$generate = plugin.generate) === null || _plugin$generate === void 0 ? void 0 : _plugin$generate.bind(plugin);

  if (!generate) {
    throw new Error(`${pluginName} does not have a generate method`);
  }

  let {
    content,
    map
  } = await generate({
    asset: new (_Asset().Asset)(asset),
    ast,
    options: new (_PluginOptions().default)(asset.options),
    logger: new (_logger().PluginLogger)({
      origin: pluginName
    })
  });
  let mapBuffer = map === null || map === void 0 ? void 0 : map.toBuffer(); // Store the results in the cache so we can avoid generating again next time

  await Promise.all([asset.options.cache.setStream((0, _nullthrows().default)(asset.value.contentKey), (0, _utils().blobToStream)(content)), mapBuffer != null && asset.options.cache.setBlob((0, _nullthrows().default)(asset.value.mapKey), mapBuffer)]);
  return {
    content: content instanceof _stream().Readable ? asset.options.cache.getStream((0, _nullthrows().default)(asset.value.contentKey)) : content,
    map
  };
}

async function getConfig(asset, filePaths, options) {
  let packageKey = options === null || options === void 0 ? void 0 : options.packageKey;
  let parse = options && options.parse;

  if (packageKey != null) {
    let pkg = await asset.getPackage();

    if (pkg && pkg[packageKey]) {
      return {
        config: pkg[packageKey],
        // The package.json file was already registered by asset.getPackage() -> asset.getConfig()
        files: []
      };
    }
  }

  let conf = await (0, _utils().loadConfig)(asset.options.inputFS, asset.value.filePath, filePaths, parse == null ? null : {
    parse
  });

  if (!conf) {
    return null;
  }

  return conf;
}

function getInvalidationId(invalidation) {
  switch (invalidation.type) {
    case 'file':
      return 'file:' + invalidation.filePath;

    case 'env':
      return 'env:' + invalidation.key;

    case 'option':
      return 'option:' + invalidation.key;

    default:
      throw new Error('Unknown invalidation type: ' + invalidation.type);
  }
}

const hashCache = (0, _buildCache().createBuildCache)();

async function getInvalidationHash(invalidations, options) {
  if (invalidations.length === 0) {
    return '';
  }

  let sortedInvalidations = invalidations.slice().sort((a, b) => getInvalidationId(a) < getInvalidationId(b) ? -1 : 1);

  let hash = _crypto().default.createHash('md5');

  for (let invalidation of sortedInvalidations) {
    switch (invalidation.type) {
      case 'file':
        {
          // Only recompute the hash of this file if we haven't seen it already during this build.
          let fileHash = hashCache.get(invalidation.filePath);

          if (fileHash == null) {
            fileHash = await (0, _utils().md5FromFilePath)(options.inputFS, invalidation.filePath);
            hashCache.set(invalidation.filePath, fileHash);
          }

          hash.update(fileHash);
          break;
        }

      case 'env':
        hash.update(invalidation.key + ':' + (options.env[invalidation.key] || ''));
        break;

      case 'option':
        hash.update(invalidation.key + ':' + (0, _utils2().hashFromOption)(options[invalidation.key]));
        break;

      default:
        throw new Error('Unknown invalidation type: ' + invalidation.type);
    }
  }

  return hash.digest('hex');
}