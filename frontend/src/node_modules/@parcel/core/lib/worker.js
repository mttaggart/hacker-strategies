"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearConfigCache = clearConfigCache;
exports.runTransform = runTransform;
exports.runValidate = runValidate;
exports.runPackage = runPackage;
exports.invalidateRequireCache = invalidateRequireCache;

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _BundleGraph() {
  const data = _interopRequireDefault(require("./BundleGraph"));

  _BundleGraph = function () {
    return data;
  };

  return data;
}

function _Transformation() {
  const data = _interopRequireDefault(require("./Transformation"));

  _Transformation = function () {
    return data;
  };

  return data;
}

function _ReporterRunner() {
  const data = require("./ReporterRunner");

  _ReporterRunner = function () {
    return data;
  };

  return data;
}

function _PackagerRunner() {
  const data = _interopRequireDefault(require("./PackagerRunner"));

  _PackagerRunner = function () {
    return data;
  };

  return data;
}

function _Validation() {
  const data = _interopRequireDefault(require("./Validation"));

  _Validation = function () {
    return data;
  };

  return data;
}

function _ParcelConfig() {
  const data = _interopRequireDefault(require("./ParcelConfig"));

  _ParcelConfig = function () {
    return data;
  };

  return data;
}

function _utils2() {
  const data = require("./utils");

  _utils2 = function () {
    return data;
  };

  return data;
}

function _buildCache() {
  const data = require("./buildCache");

  _buildCache = function () {
    return data;
  };

  return data;
}

require("@parcel/cache");

require("@parcel/package-manager");

require("@parcel/fs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// register with serializer
(0, _utils2().registerCoreWithSerializer)(); // Remove the workerApi type from the TransformationOpts and ValidationOpts types:
// https://github.com/facebook/flow/issues/2835

// TODO: this should eventually be replaced by an in memory cache layer
let parcelConfigCache = new Map();

function loadOptions(ref, workerApi) {
  return (0, _nullthrows().default)(workerApi.getSharedReference(ref // $FlowFixMe
  ));
}

async function loadConfig(cachePath, options) {
  let config = parcelConfigCache.get(cachePath);

  if (config && config.options === options) {
    return config;
  }

  let processedConfig = (0, _nullthrows().default)(await options.cache.get(cachePath));
  config = new (_ParcelConfig().default)( // $FlowFixMe
  processedConfig, options);
  parcelConfigCache.set(cachePath, config);
  return config;
}

function clearConfigCache() {
  _utils().loadConfig.clear();

  (0, _buildCache().clearBuildCaches)();
}

async function runTransform(workerApi, opts) {
  let {
    optionsRef,
    configCachePath,
    ...rest
  } = opts;
  let options = loadOptions(optionsRef, workerApi);
  let config = await loadConfig(configCachePath, options);
  return new (_Transformation().default)({
    workerApi,
    report: _ReporterRunner().reportWorker.bind(null, workerApi),
    options,
    config,
    ...rest
  }).run();
}

async function runValidate(workerApi, opts) {
  let {
    optionsRef,
    configCachePath,
    ...rest
  } = opts;
  let options = loadOptions(optionsRef, workerApi);
  let config = await loadConfig(configCachePath, options);
  return new (_Validation().default)({
    workerApi,
    report: _ReporterRunner().reportWorker.bind(null, workerApi),
    options,
    config,
    ...rest
  }).run();
}

async function runPackage(workerApi, {
  bundle,
  bundleGraphReference,
  configRef,
  optionsRef
}) {
  var _await$runner$getBund;

  let bundleGraph = workerApi.getSharedReference(bundleGraphReference);
  (0, _assert().default)(bundleGraph instanceof _BundleGraph().default);
  let options = loadOptions(optionsRef, workerApi);
  let processedConfig = workerApi.getSharedReference(configRef // $FlowFixMe
  );
  let parcelConfig = new (_ParcelConfig().default)(processedConfig, options);
  let runner = new (_PackagerRunner().default)({
    config: parcelConfig,
    options,
    report: _ReporterRunner().reportWorker.bind(null, workerApi)
  });
  let configs = await runner.loadConfigs(bundleGraph, bundle); // TODO: add invalidations in `config?.files` once packaging is a request

  let cacheKey = await runner.getCacheKey(bundle, bundleGraph, configs);
  let cacheKeys = {
    content: _PackagerRunner().default.getContentKey(cacheKey),
    map: _PackagerRunner().default.getMapKey(cacheKey),
    info: _PackagerRunner().default.getInfoKey(cacheKey)
  };
  return (_await$runner$getBund = await runner.getBundleInfoFromCache(cacheKeys.info)) !== null && _await$runner$getBund !== void 0 ? _await$runner$getBund : runner.getBundleInfo(bundle, bundleGraph, cacheKeys, configs);
}

const PKG_RE = /node_modules[/\\]((?:@[^/\\]+[/\\][^/\\]+)|[^/\\]+)(?!.*[/\\]node_modules[/\\])/;

function invalidateRequireCache() {
  throw new Error('invalidateRequireCache is only for tests');
}