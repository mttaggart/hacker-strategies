"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getEnvOptions;

function _presetEnv() {
  const data = _interopRequireDefault(require("@babel/preset-env"));

  _presetEnv = function () {
    return data;
  };

  return data;
}

function _getBabelTargets() {
  const data = _interopRequireDefault(require("./getBabelTargets"));

  _getBabelTargets = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Generates a @babel/preset-env config for an asset.
 * This is done by finding the source module's target engines, and the app's
 * target engines, and doing a diff to include only the necessary plugins.
 */
async function getEnvOptions(config) {
  // Only compile if there are engines defined in the environment.
  if (Object.keys(config.env.engines).length === 0) {
    return null;
  } // Load the target engines for the app and generate a @babel/preset-env config


  let appBabelTargets = (0, _utils().enginesToBabelTargets)(config.env); // If this is the app module, the source and target will be the same, so just compile everything.
  // Otherwise, load the source engines and generate a babel-present-env config.

  if (!config.isSource) {
    let sourceBabelTargets = await (0, _getBabelTargets().default)(config);

    if (!sourceBabelTargets || !shouldCompileFurther(sourceBabelTargets, appBabelTargets)) {
      return null;
    }
  }

  return {
    targets: appBabelTargets,
    config: {
      presets: ['@parcel/babel-preset-env']
    }
  };
}

function getNeededPlugins(targets) {
  return (0, _presetEnv().default)({
    assertVersion: () => true
  }, {
    targets: targets
  }).plugins.filter(p => p[0]);
}

function shouldCompileFurther(sourceBabelTargets, appBabelTargets) {
  let sourcePlugins = new Set(getNeededPlugins(sourceBabelTargets));
  let appPlugins = getNeededPlugins(appBabelTargets); // If there is any app plugin present that was not used to compile the source,
  // then the asset was built to a higher target and will need to be compiled
  // further

  return appPlugins.some(plugin => {
    return !sourcePlugins.has(plugin);
  });
}